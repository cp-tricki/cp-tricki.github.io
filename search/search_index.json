{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Welcome to CP-tricki! This is a collection of small tricks for competitive programming inspired by Tricki. You can browse (and, we hope, enjoy) available (currently only few) pages on the navbar. </p> <p></p>"},{"location":"#contributing","title":"Contributing","text":"<p>To contribute, you can:</p> <ul> <li>Create a pull request from fork (can be fully done via GitHub's web interface)</li> <li>Or, open an issue with proposed changes</li> </ul>"},{"location":"#article-formatting","title":"Article formatting","text":""},{"location":"#article-titles","title":"Article titles","text":"<p>When creating a new Markdown file, specify article title via <pre><code>---\ntitle: Your title\n---\n</code></pre> Another option is to use <code># Your title</code>, but we do not recommend it.</p>"},{"location":"#code","title":"Code","text":"<p>To insert code, use <pre><code>``` c++\n#include &lt;bits/stdc++.h&gt;\n```\n</code></pre> This will render as <pre><code>#include &lt;bits/stdc++.h&gt;\n</code></pre> Specifying programming language after backticks enables code highlighting.</p>"},{"location":"#text-and-subheadings","title":"Text and subheadings","text":"<p>To break text on the page into paragraphs, simply leave a blank line between two bodies of text. To insert subheadings, put <code>## HTML h2 heading</code>, <code>### HTML h3 heading</code>, <code>#### HTML h4 heading</code> etc. on separate line. Using <code># HTML h1 heading</code> is not recommended.</p>"},{"location":"#math","title":"Math","text":"<p>To add math, use <code>\\( n^2 = -1 \\)</code> inline. This will render as \\( n^2 = -1 \\). To put a formula in a separate block, use  <pre><code>blank line\n\\[\n\\int e^x dx = e^x + C\n\\]\nblank line\n</code></pre> This will result in </p> \\[ \\int e^x dx = e^x + C \\] <p>Note: GitHub's preview can display brackets incorrectly.</p>"},{"location":"Numerical%20optimisation/How%20to%20use%20ternary%20search/","title":"How to use ternary search","text":""},{"location":"Numerical%20optimisation/How%20to%20use%20ternary%20search/#short-description","title":"Short description","text":"<p>In practice, functions which first decrease and then increase (or vice versa) occur frequently. Then, one can use ternary search to find the optimal value. </p>"},{"location":"Numerical%20optimisation/How%20to%20use%20ternary%20search/#prerequisites","title":"Prerequisites","text":"<p>Perhaps basic familiarity with binary search would be useful.</p>"},{"location":"Numerical%20optimisation/How%20to%20use%20ternary%20search/#long-description","title":"Long description","text":"<p>General idea. There are a lot of unimodal functions (these are functions which first increase and then decrease or vice versa) especially of the geometrical flavour. In that case, one can use ternary search in order to find the extremum. One can think about the suitable functions in the following way: if the argument of our function is very large (or very small) then the value is bad, because \"it's far\". And when we move our argument closer to the optimal one, the value constantly improves. For most functions it is more or less easy to prove rigorously after some technical efforts.</p> <p>Speed up. If one know the general scheme of ternary search algorithm, they won't be surprised that we can choose arbitrary points to proceed, now just at the thirds. For instance, the segment ratio like \\(\\varphi : 1 : \\varphi\\) or \\(1 : \\varphi : 1\\), where \\(\\varphi = (1+\\sqrt{5})/2\\) would be a better choice if we apply memoization to long-working cost (or penalty) function we optimise. </p> <p>Multidimensional ternary search. See here.</p> <p>What follows is a sheaf of examples. </p>"},{"location":"Numerical%20optimisation/How%20to%20use%20ternary%20search/#example-1","title":"Example 1","text":"<p>Town X is in the point \\((0,1)\\), and Town Y in the point is in the point \\((1,0)\\). There is a line \\(y=a\\), where \\(0\\leq a\\leq 1\\). Speed when \\(y&lt;a\\) is \\(v_1\\) and speed when \\(y&gt;a\\) is \\(v_2\\). Find the minimal time to go from Town X to Town Y. </p> <p>Explanation.</p> <p>In any way we need to intersect the line \\(y=a\\). Let \\((x,a)\\) be a point on that line in which we are going to intersect it. The time then is</p> \\[     f(x) = \\frac{\\sqrt{x^2+(a-1)^2}}{v_1} +      \\frac{\\sqrt{(x-1)^2+a^2}}{v_2}  \\] <p>This function is clearly unimodal, hence we can use ternary search to find the optimal \\(x\\). The generalisation of this problem can be solved using Lagrange multipliers. </p>"},{"location":"Numerical%20optimisation/How%20to%20use%20ternary%20search/#example-2","title":"Example 2","text":"<p>There are \\(n\\) lines in the plane. Find a point such that the sum of distances from it to these lines are minimal.</p> <p>Explanation.</p> <p>Given a fixed \\(x\\)-coordinate one easily finds the optimal \\(y\\)-coordinate \\(find\\_opt(x)\\). Then, to find an optimal \\(x\\)-coordinate one do nested ternary searches when comparing: \\(calc(a, find\\_opt(a))\\). </p>"},{"location":"Numerical%20optimisation/How%20to%20use%20ternary%20search/#example-3","title":"Example 3","text":"<p>(One can imagine towers of boxes in the following problem.) Given an array \\(a_1,\\dots,a_n\\) such that \\(a_k \\geq 0\\) for all \\(k\\), one can perform two operations:</p> <ul> <li> <p>choose \\(k\\) and increase \\(a_k\\) by one,</p> </li> <li> <p>choose \\(k\\) such that \\(a_k\\geq 1\\) and decrease it by one. </p> </li> </ul> <p>Find the minimal value of operations needed to make at least \\(M\\) numbers in the array equal.</p> <p>Explanation.</p> <p>Let \\(H\\) be a desired height for those \"at least \\(M\\)\". We can greedily calculate the number of operations needed. More or less it is clear that this function is unimodal. </p>"},{"location":"Numerical%20optimisation/How%20to%20use%20ternary%20search/#example-4","title":"Example 4","text":"<p>There are \\(n\\) fans who live on \\(x\\)-axis in coordinates \\(x_1,\\dots,x_n\\). Also, \\(k\\)-th person has speed \\(v_i\\) m/s and can hear if the source is not farer than \\(d_i\\) meters from themselves. A band wants to give a concert in such an integer point that they total time people spent to reach a point when they can hear the concert is minimal.</p> <p>Explanation.</p> <p>Perform ternary search of \\(x\\)-coordinate of the concert. Then, compute how much time people need to get the nearest hearable point. </p>"},{"location":"combinatorics/Counting%20labeled%20trees/","title":"Counting labeled trees","text":""},{"location":"combinatorics/Counting%20labeled%20trees/#prerequisites","title":"Prerequisites.","text":"<p>Only very basic enumerative combinatorics.</p>"},{"location":"combinatorics/Counting%20labeled%20trees/#short-description","title":"Short description.","text":"<p>Some problems on labeled trees that does not involve much of internal structure can be reduced to the more straightforward problems on arrays. </p>"},{"location":"combinatorics/Counting%20labeled%20trees/#general-description","title":"General description.","text":"<p>Apart from other heavy methods of counting labeled structures (graphs, say) such as generating functions, there is a remarkably elementary method called Pr\u00fcfer bijection.</p> <p>In short, this is well-behaved combinatorial construction that establish bijection:</p> \\[ \\Big\\{\\text{labeled trees on $\\{1,\\dots,n\\}$}\\Big\\}  \\longleftrightarrow \\Big\\{\\text{arrays on $\\{1,\\dots,n\\}$ of length $n-2$}\\Big\\} \\] <p>which is build explicitly using the algorithm described well here as well as in many other Internet resources. Returning to the point, we reduce problem on trees to the problem on arbitrary sequences of fixed length. The rest now is just to note several useful properties, for example that every index, say \\(v\\), occurs \\(\\deg v-1\\) times, hence, for example, no leaves occur in the sequence. One more remarkable corollary from this bijection, so-called Cayley's formula, is the fact that the number of label trees on \\(\\{1,\\dots,n\\}\\) is equal to \\(n^{n-2}\\); if one proceed more carefully, the formula \\(T_{n,k} = k n^{n-k-1}\\) for the number of labeled forests with \\(k\\) connected components is easily derivable. </p> <p>In short, Pr\u00fcfer codes gives a simple combinatorial way to control labeled trees (and forests), though mostly in terms of degrees of their vertices. </p>"},{"location":"combinatorics/Counting%20labeled%20trees/#example-1","title":"Example 1.","text":"<p>This is a bit artificial example, but it keeps everything simple and gives a clue how to solve such kind of problems.</p> <p>Find the number of labeled trees on \\(\\{1,\\dots,N\\}\\) such that the degrees of all vertices but leaves are equal.</p> <p>Consider arrays instead of trees. We know that the number of occurrences of a vertex \\(v\\) is equal to \\((\\deg v - 1)\\). So, in the array which encodes the proper tree we have the equal number of occurrences of each number. So, the combinatorial task now is rather easy: - choose \\(d\\) numbers (where \\(d\\) divides \\(n-2\\)) from \\(\\{1,\\dots,n\\}\\) which will occur in the array. - find the number to put the selected numbers them into \\((n-2)\\) cells, using multinomial coefficients. </p>"},{"location":"combinatorics/Counting%20labeled%20trees/#online-judges","title":"Online Judges","text":"<ol> <li>Functional Graph Distribution </li> <li>Sasha and Interesting Fact from Graph Theory</li> <li>Tree Sum</li> <li>Clues</li> </ol>"},{"location":"combinatorics/One%20can%20process%20bits%20independently%20when%20relevant/","title":"One can process bits independently when relevant","text":""},{"location":"combinatorics/One%20can%20process%20bits%20independently%20when%20relevant/#short-description","title":"Short description","text":"<p>If the problem is related with some bitwise operations (especially xor), try to think and process each bit independently.</p>"},{"location":"combinatorics/One%20can%20process%20bits%20independently%20when%20relevant/#prerequisites","title":"Prerequisites","text":"<p>The knowledge of bitmasks (bitwise operations)</p>"},{"location":"combinatorics/One%20can%20process%20bits%20independently%20when%20relevant/#general-description","title":"General description","text":"<p>Each integer \\(x\\) can be represented as \\(\\sum\\limits_{k=0}^{M} 2^k \\cdot b_k\\) where \\(b_k\\) is \\(k\\)-th bit in binary representation of the integer and \\(M\\) is \\(\\log_{2}{x}\\).</p> <p>It is often difficult to follow all bits simultaneously, however, we can transform the expression in such way, that bits are calculated independently.</p>"},{"location":"combinatorics/One%20can%20process%20bits%20independently%20when%20relevant/#example","title":"Example","text":"<p>The task is to calculate \\(\\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n} (a_l \\oplus \\dots \\oplus a_r)\\)</p> <p>Explanations</p> <p>Let's use the trick so the expression will take form</p> \\[ \\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n} (a_l \\oplus \\dots \\oplus a_r)= \\] \\[ \\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n} (\\sum\\limits_{k=0}^{M} (2^k \\cdot b_{l,k}) \\oplus \\dots \\oplus \\sum\\limits_{k=0}^{M} (2^k \\cdot b_{r,k}))\\overset{*}{=}  \\] \\[ \\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n}\\sum\\limits_{k=0}^{M} 2^k\\cdot (b_{l,k} \\oplus \\dots \\oplus b_{r,k})= \\] \\[ \\sum\\limits_{k=0}^{M}2^k\\cdot \\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n}  (b_{l,k} \\oplus \\dots \\oplus b_{r,k}), \\] <p>where \\(b_{i,k}\\) is the \\(k\\)-th bit of \\(a_i\\) and it is equal to \\(0\\) or \\(1\\).</p> <p>It's correct to do (\\(\\ast\\)) above because multiplying by \\(2^k\\) is equal to shifting \\(k\\) bits right, and \\((a\\ll x)\\oplus (b\\ll x)=(a\\oplus b)\\ll x\\).</p> <p>Actually, the expression \\((b_{l,k} \\oplus \\dots \\oplus b_{r,k})\\) is also equal to \\(0\\) or \\(1\\)(number of ones on the segment is odd). Hence it is much easier to calculate this sum (equivalently the number of segments with odd sum).</p>"},{"location":"combinatorics/One%20can%20process%20bits%20independently%20when%20relevant/#online-judge","title":"Online Judge","text":"<ol> <li>Krosh and one more problem with xors</li> <li>Convolution XOR SUM</li> <li>XOR on Segment</li> <li>Present</li> </ol>"},{"location":"combinatorics/One%20can%20use%20determinants%20to%20count%20lattice%20paths/","title":"One can use determinants to count lattice paths","text":""},{"location":"combinatorics/One%20can%20use%20determinants%20to%20count%20lattice%20paths/#short-description","title":"Short description","text":"<p>Occasionally we can encounter the combinatorial nature of determinant in other kind of problems and exploit it writing down this underlying determinant and simplifying it mathematically (or evaluating it straightforwardly when possible).</p>"},{"location":"combinatorics/One%20can%20use%20determinants%20to%20count%20lattice%20paths/#long-description-1","title":"Long description - 1","text":"<p>A lot of interesting mathematics hides behind the aforementioned phenomenon will be omitted here, but we shall elaborate more on practical point.</p> <p>First of all, of course, comes so-called Lindstr\u00f6m-Gessel-Viennot lemma. The detailed treatment is given by the link, so we just roughly describe the idea here.</p> <p>Let \\(G\\) be a oriented acyclic graph with two sets of marked vertices \\(A=(A_1,\\dots,A_n)\\) and \\(B=(B_1,\\dots,B_n)\\). Then, consider a matrix \\(M\\) such that \\(M_{i,j}\\) is the number of paths between \\(A_i\\) and \\(B_j\\). Computing its determinant,</p> \\[ \\det M = \\sum_{\\pi} sign(\\pi) M_{1\\pi_1} \\dots M_{n\\pi_n} \\] <p>one obtains an interesting combinatorial interpretation because the product is the number of paths systems \\(\\{A_i\\to B_{\\pi_i}\\}\\) for some permutation \\(\\pi\\), so one obtains</p> \\[     \\det M = \\sum_{\\text{paths systems}(\\pi)} sign(\\pi). \\] <p>Now we can split the sum into two key summands and, as always, expect that the main part will remain, while the \"correlation\" part vanishes:</p> \\[     \\det M = \\sum_{\\text{non-intersc}(\\pi)} sign(\\pi) + \\sum_{\\text{intersc}(\\pi)} sign(\\pi). \\] <p>Indeed, one can build an involution on the set of the intersecting paths systems, which changes the sign of the underlying permutation. That leads, of course, to the vanishing of the second summand, hence, we obtain the so-called unweighted LGV lemma:</p> \\[     \\det M = \\sum_{\\text{non-intersc}(\\pi)} sign(\\pi). \\] <p>In practice, it usually turns out that the only non-intersecting paths system is that, which corresponds to the identity permutation.</p>"},{"location":"combinatorics/One%20can%20use%20determinants%20to%20count%20lattice%20paths/#example-1","title":"Example 1.","text":"<p>Some of examples can be found in the mentioned reference to LGV.</p>"},{"location":"combinatorics/One%20can%20use%20determinants%20to%20count%20lattice%20paths/#example-2","title":"Example 2.","text":"<p>Actually, to apply this trick one have to always remember the proof of LGV, because this strategy is applicable in a number of similar situations, where we can exploit the cancellative nature of determinant.</p> <p>For example, let's describe the similar trick to derive the hook-length formula. One can represent Young diagram \\(\\lambda= (\\lambda_1,\\dots,\\lambda_k)\\) as the point on real line using the classical Russian construction, and adding cells as the process on those ball, more precisely, one ball jumps over another one. Then, the problem of finding the dimension (the number of standard Young tableaux) of \\(\\lambda\\) reduces to the solving the following problem:</p> <p>The cells \\(0, 1, \\dots, k-1\\) contain balls, exactly one in each. We can move one ball by one further, if the next cell is empty. How many ways to reach \\(l_1, \\dots, l_k\\), where these numbers are determined by \\(\\lambda\\). </p> <p>The solution to this problem uses the very similar strategy to the the Lindstr\u00f6m-Gessel-Viennot. We, first, find the total number of such \"path systems\" (ball processes) with no restriction of non-emptiness. Then, for \"intersecting path systems\" (bad ball processes) we can swap two balls at the time they are in the same cell and make similar calculations. Then we generalise the situation to the arbitrary number of balls, obtaining the determinantal formula for the dimension (number of standard Young tableaux). Then, we just make some algebra and obtain the desired hook-length formula. </p>"},{"location":"combinatorics/One%20can%20use%20determinants%20to%20count%20lattice%20paths/#online-judges","title":"Online Judges","text":"<p>Again, look up in the blog. </p>"},{"location":"combinatorics/Permutations%20can%20be%20represented%20as%20graphs/","title":"Permutations can be represented as graphs","text":""},{"location":"combinatorics/Permutations%20can%20be%20represented%20as%20graphs/#short-description","title":"Short description","text":"<p>If the problem is about permutations, try to think about them as graphs.</p>"},{"location":"combinatorics/Permutations%20can%20be%20represented%20as%20graphs/#prerequisites","title":"Prerequisites","text":"<p>No specific knowledge.</p>"},{"location":"combinatorics/Permutations%20can%20be%20represented%20as%20graphs/#general-description","title":"General description","text":"<p>Consider a permutation \\(p_1,p_2,\\dots, p_n\\). Let's construct an undirected graph where exist an edge between \\(i\\) \\(\\leftrightarrow\\) \\(p_i\\). In such construction this graph will contain only cycles (isolated vertex-loop, forward-backward edges or usual cycles). For example \\([2,4,5,1,3]\\) will split into \\((2 4 1)(5 3)\\). In problems, it may be efficient to consider each cycle independently.</p>"},{"location":"combinatorics/Permutations%20can%20be%20represented%20as%20graphs/#example-1","title":"Example 1","text":"<p>Given a permutation \\(a\\). You can choose any two indexes \\(i,j\\) and swap \\(a_i,a_j\\). What is the minimal number of swaps to make the permutation sorted?</p>"},{"location":"combinatorics/Permutations%20can%20be%20represented%20as%20graphs/#explanations","title":"Explanations","text":"<p>Let's consider a cycle of the permutation. Suppose it's length is \\(m\\). We can make all the elements from the cycle to be on their places in \\(m-1\\) operations. That's because if \\(m-1\\) elements will be on their place, the \\(m\\)-th will also be on its place.</p> <p>So the answer to the problem is the sum of cycle lengths minus the number of cycles. If the number of cycles is \\(c\\) than the answer is \\(n-c\\).</p>"},{"location":"combinatorics/Permutations%20can%20be%20represented%20as%20graphs/#example-2","title":"Example 2","text":"<p>You need to process two types of queries:</p> <ul> <li>swap \\(p_x,p_y\\).</li> <li>find the value of \\(i\\) if you assign \\(i=p_i\\) \\(k\\) times.</li> </ul>"},{"location":"combinatorics/Permutations%20can%20be%20represented%20as%20graphs/#explanations_1","title":"Explanations","text":"<p>Let \\(S\\approx \\sqrt{n}\\). For each \\(i\\) we can calculate the position of \\(i\\) after applying \\(S\\) times \\(i=p_i\\). (Very similar to the technique using in tree jumping). Now, we can answer the second query in \\(O(\\frac{k}{S}+S)\\) jumping \\(\\frac{k}{S}\\) times with the step of length \\(S\\), what is precalculated, and the remainder jumps with step of length \\(1\\).</p> <p>To perform updates, you should notice that only \\(2 \\cdot S\\) values will change (\\(S\\) jumps forward and \\(S\\) jumps back).</p>"},{"location":"combinatorics/Permutations%20can%20be%20represented%20as%20graphs/#online-judges","title":"Online judges","text":"<ul> <li>Minimum Swaps 2</li> <li>Swap Round Sorting</li> <li>Permutation and Queries</li> <li>Lucky Permutation</li> </ul>"},{"location":"combinatorics/Small%20number%20of%20groups%20can%20be%20processed%20straightforwardly/","title":"Small number of groups can be processed straightforwardly","text":""},{"location":"combinatorics/Small%20number%20of%20groups%20can%20be%20processed%20straightforwardly/#short-description","title":"Short description","text":"<p>If the task is to say something about functions try to split them into groups with the same qualities.</p>"},{"location":"combinatorics/Small%20number%20of%20groups%20can%20be%20processed%20straightforwardly/#prerequisites","title":"Prerequisites","text":"<p>Basic knowledge.</p>"},{"location":"combinatorics/Small%20number%20of%20groups%20can%20be%20processed%20straightforwardly/#long-description","title":"Long description","text":"<p>Sometimes it may be efficient to observe how the function changes. For example, it can rapidly increase or decrease. In such cases you can divide it into groups of equal values and the total number of groups will be rather small.</p> <p>Usually such functions are related with \\(\\gcd\\) or bitwise operations. </p>"},{"location":"combinatorics/Small%20number%20of%20groups%20can%20be%20processed%20straightforwardly/#example-1","title":"Example 1","text":"<p>Given an array \\(a_1,a_2,\\dots a_n\\). Let \\(F(l,r)\\) is bitwise AND of the elements on the segment \\([l,r]\\). Count the number of different \\(F(l,r)\\) for all pairs \\(1\\le l \\le r\\le n\\).</p> <p>Explanation</p> <p>Notice that \\(F(l,r)=F(l,r+1)\\) or \\(F(l,r) &gt; F(l,r+1)\\) and the number of second cases is small. When the function decreases, it means that bits are removed. And the amount of bits is limited with \\(\\log_{2}{A}\\). So we can jump through the values of \\(F(l,r)\\) which are equal and the number of such jumps will be rather small.</p>"},{"location":"combinatorics/Small%20number%20of%20groups%20can%20be%20processed%20straightforwardly/#example-2","title":"Example 2","text":"<p>Given two arrays \\(c_1,c_2,\\dots, c_n\\) and \\(f_1,f_2,\\dots,f_n\\). At first you have \\(T=1\\).  You perform \\(n\\) steps. On the \\(i\\)-th you: - Choose \\(k\\ge 0\\) and multiply \\(T\\) by \\(2^k\\). - Add \\(f_i\\cdot \\lfloor \\frac{c_i}{T} \\rfloor\\) to the answer. Maximize the answer.</p> <p>Explanations</p> <p>Let \\(ans[i][k]\\) is equal to the maximal answer of the first \\(i\\) elements where \\(T\\) is equal to \\(2^k\\). Notice, that we should consider \\(k\\) only up to \\(\\log_{2}{c_i}\\), because otherwise \\(f_i\\cdot \\lfloor \\frac{c_i}{T} \\rfloor=0\\). The transitions are: </p> \\[ ans[i][k]=\\max\\limits_{k'=0}^{k}ans[i-1][k']+f_i\\cdot \\lfloor \\frac{c_i}{2^k} \\rfloor. \\]"},{"location":"combinatorics/Small%20number%20of%20groups%20can%20be%20processed%20straightforwardly/#online-judges","title":"Online judges","text":"<ul> <li>Shortcuts</li> <li>wxhtzdy ORO Tree</li> <li>MEX of LCM</li> <li>\u0420\u0443\u0434\u043e\u043b\u044c\u0444 \u0438 \u043a\u043e\u043a\u0442\u0435\u0439\u043b\u0438 (only Russian statement available)</li> </ul>"},{"location":"dp/Use%20diagonals%20as%20parameters%20in%20grid%20DP%20problems/","title":"Use diagonals as parameters in grid DP problems","text":""},{"location":"dp/Use%20diagonals%20as%20parameters%20in%20grid%20DP%20problems/#short-description","title":"Short description","text":"<p>If the problem is about paths in a grid and you've came up with non optimal dp solution, try to use the number of diagonals in dp as parameter.</p>"},{"location":"dp/Use%20diagonals%20as%20parameters%20in%20grid%20DP%20problems/#prerequisites","title":"Prerequisites","text":"<p>Dynamical programming.</p>"},{"location":"dp/Use%20diagonals%20as%20parameters%20in%20grid%20DP%20problems/#long-description","title":"Long description","text":"<p>The idea is to use the number of processed diagonals as a parameter. For example for diagonal \\(d=3\\) we will consider cells \\((3,1)\\), \\((2,2)\\), \\((1,3)\\). It can be also represented as the number of moves made to reach the diagonal. When we maintain the diagonal \\(d\\) and the column \\(i\\), we can express the row as \\(j=d-i+1\\) and do the transitions as usual. This trick mainly helps when you need to process more than one path which depend on the number of moves.</p>"},{"location":"dp/Use%20diagonals%20as%20parameters%20in%20grid%20DP%20problems/#example-1","title":"Example 1","text":"<p>You are given a grid \\(A\\) of size \\(n\\times n\\), and a number \\(A_{i,j}\\) in each cell. Find two paths starting at \\((1,1)\\), end at \\((n,n)\\) such that sum of unions of these paths must is maximal.</p> <p>Explanations</p> <p>Let \\(ans[d][i_1][i_2]\\) be the answer to the problem if we are on the \\(d\\)-th diagonal, first path ends in column \\(i_1\\) and the second path ends in column \\(i_2\\). The answer to the problem is \\(ans[2n-1][n][n]\\). Since we can get the rows for both paths the transitions are obvious. Using this trick we get rid of maintaining \\(j_1,j_2\\) and have a solution in \\(O(n^3)\\) instead of \\(O(n^4)\\).</p>"},{"location":"dp/Use%20diagonals%20as%20parameters%20in%20grid%20DP%20problems/#online-judges","title":"Online judges","text":"<ul> <li>Relay Race</li> <li>Pig and Palindromes</li> </ul>"},{"location":"dp/translate-dp-to-the-matrix-form/","title":"Translate DP to the matrix form","text":""},{"location":"dp/translate-dp-to-the-matrix-form/#short-description","title":"Short description","text":"<p>Sometimes, we can rewrite our dynamic programming transition formulae using matrices and operations between them (most remarkably multiplication). Then, we can exploit this form in some way.</p>"},{"location":"dp/translate-dp-to-the-matrix-form/#prerequisites","title":"Prerequisites","text":"<p>Basic familiarity with dynamic programming and matrices (linear algebra in general does not required).</p>"},{"location":"dp/translate-dp-to-the-matrix-form/#general-description","title":"General description","text":"<p>We shall not follow the most general setting here, instead focusing on the following DP (linear rerecurrenceelation):</p> \\[     dp_n = a_1 dp_{n-1} + a_2 dp_{n-2} + \\dots + a_k dp_{n-k}. \\] <p>Then, one can notice that the right hand side can be expressed as the dot product</p> \\[     a_1 dp_{n-1} + \\dots + a_k dp_{n-k} =      \\begin{pmatrix}         a_1 &amp; a_2 &amp; \\dots &amp; a_k     \\end{pmatrix}     \\begin{pmatrix}         dp_{n-1} &amp; dp_{n-2} &amp; \\dots &amp; dp_{n-k}     \\end{pmatrix}^T. \\] <p>These vectors on their own are very natural: the first one is our coefficients and the second one keeps our recent values of DP.  The key idea now is to obtain the next vector of recent values, namely \\( \\begin{pmatrix} dp_n &amp; dp_{n-1} &amp; \\dots &amp; dp_{n-k+1} \\end{pmatrix}^T \\).  To do so, we need to apply our previous relation, and then shift all the other values (as well as eliminate \\(dp_{n-k}\\) because we will not need it further). Is it actually easy to shift, so we have the following identity </p> \\[     \\begin{pmatrix}         dp_{n}\\\\         dp_{n-1}\\\\         \\vdots\\\\         dp_{n-k+2}\\\\         dp_{n-k+1}     \\end{pmatrix} =     \\begin{pmatrix}         a_1    &amp; a_2    &amp; \\dots  &amp; a_{k-1} &amp; a_k\\\\         1      &amp; 0      &amp; \\dots  &amp; 0       &amp; 0\\\\         0      &amp; 1      &amp; \\dots  &amp; 0       &amp; 0\\\\         \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots  &amp; \\vdots\\\\         0      &amp; 0      &amp; \\dots  &amp; 1       &amp; 0     \\end{pmatrix}     \\begin{pmatrix}         dp_{n-1} \\\\         dp_{n-2} \\\\         \\vdots\\\\         dp_{n-k+1}\\\\         dp_{n-k}     \\end{pmatrix} \\] <p>Or, in a more compact form (\\(A\\) is the large matrix on the left hand side)</p> \\[     recent_n = A~recent_{n-1}, \\] <p>where \\(recent_n\\) is the vector \\((dp_n, dp_{n-1}, \\dots, dp_{n-k+1}\\) which contains the last \\(k\\) dp values.  We can inductively deduce</p> \\[     recent_n = A recent_{n-1} = A^2 recent_{n-2} = \\dots = A^{n-k+1} recent_{k-1}. \\] <p>Matrix multiplication can be done in \\(O(k^3)\\), and using binary exponentiation we obtain \\(O(k^3 \\log n)\\) algorithm.</p>"},{"location":"dp/translate-dp-to-the-matrix-form/#example-1-constant","title":"Example 1 (+constant)","text":"<p>Given \\(dp_n = A dp_{n-1} + B dp_{n-2} + C\\), find \\(dp_N\\) in \\(O(\\log N)\\) time. </p> <p>We can use the same idea here,</p> \\[     \\begin{pmatrix}dp_n &amp; dp_{n-1} &amp; C\\end{pmatrix} = \\begin{pmatrix}A &amp; B &amp; 1\\end{pmatrix} \\begin{pmatrix} dp_{n-1} &amp; dp_{n-2} &amp; C \\end{pmatrix} \\] <p>only adding a column to our transition matrix and the constant to our \\(recent_n\\) vector.</p>"},{"location":"dp/translate-dp-to-the-matrix-form/#example-2-twisted-dps","title":"Example 2 (twisted DPs)","text":"<p>Sometimes one needs to evaluate several twisted but simple DPs, something like (some random relations just for the sake of illustration):</p> \\[     dp^1_i = f(dp^1_{i-1}, dp^1_{i-2}, dp^2_{i-1}, dp^3_{i-2}), \\] \\[     dp^2_i = g(dp^1_{i-1}, dp^2_{i}, dp^2_{i-1}, dp^2_{i-2}), \\] \\[     dp^3_i = h(dp^2_{i-2}, dp^3_{i-1}). \\] <p>Then one can also use some kind of matrix transformation but with more convoluted \\(recent\\) vectors.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/","title":"How to come up with a comparator?","text":""},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#acknowledgements","title":"Acknowledgements","text":"<p>We start from a simple trick, which was exposed by Sergei Kopeliovich at Winter Programming School in Kharkiv in 2013.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#short-description","title":"Short description","text":"<p>If it seems that a problem can be solved by an algorithm of the form: \"arrange the objects in a suitable way and then work greedily\", there is a general strategy to devise a comparator for this sort.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#prerequisites","title":"Prerequisites","text":"<p>No specific knowledge is required, though familiarity with greedy algorithms would be useful.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#general-description","title":"General description","text":"<p>The auxiliary problem: find an order that optimises a construction (that is the essential part of the considered problem) if it is known that such an order exists.</p> <p>We first consider a simplified problem, when only two objects exist, say \\(A\\) and \\(B\\). Then our comparator should determine which order is better: \\(AB\\)\u00a0or \\(BA\\). To do so, we can normally introduce a penalty\u00a0(or a cost) function \\(f(A,B)\\)\u00a0denoting the amount of penalty\u00a0(or cost) we have if one takes object \\(A\\)\u00a0first and object \\(B\\) second.\u00a0Then our comparator chooses that order in which the penalty is minimal (or cost is maximal). If this comparator (relation) \\(A\\prec B\\) (which is \\(A\\prec B \\iff penalty(A,B)&lt;penalty(B,A)\\) or \\(cost(A,B)&gt;cost(B,A)\\)) is transitive (i.e. if \\(A\\prec B\\) and \\(B\\prec C\\) then \\(A\\prec C\\))\u00a0then after sorting all the objects with respect to it we shall obtain the optimal order.</p> <p>The main problem: find a maximal-size subset that optimises a construction. (The difference from idea 1 is that we are not forced to take all elements.)</p> <p>To do so, we use the comparator from the auxiliary problem, and take objects greedily one by one. At each step, we make a choice:</p> <ol> <li> <p>Put this object into the answer set,</p> </li> <li> <p>Replace an instance in the answer set with this object.</p> </li> </ol> <p>More generally one can write here a knapsack-like dp (if we have a subset we know the order by the auxiliary problem).</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#example-1-a-tower-of-boxes","title":"Example 1 (a tower of boxes)","text":"<p>Given \\(n\\) boxes, each of which has its weight \\(m_i\\) and the weight it can carry on the top \\(a_i\\), determine the size of the largest tower one can build. </p> <p>Step 1. Build a tower of all boxes.  In other words, we need to arrange the boxes in such a way that nothing breaks. Considering two distinct boxes, say \\(i\\) and \\(j\\), we ask: when the order \\((i,j)\\) is better than \\((j,i)\\)? Obviously, that is when the excess of our carrying abilities is greater (that is when the total weight that we can additionally carry is greater). In other words, our cost function looks like this (here box \\(j\\) stands on the top of \\(i\\)): \\(f(i, j) = \\min(\\) total weight that can be still carried by box \\(i\\), total weight that can be still carried by \\(j)\\), i.e. \\(f(i, j) = \\min(a_i - m_j , a_j)\\). Then we will build the tower in descending order of value.</p> <p>Step 2. Build a max-size tower. Sort the boxes in the increasing order with respect to the comparator from Step 1. Take them greedily: if we can put the next box below the already built tower, we do it; otherwise, we ponder whether can we replace some of the boxes in the tower with our current one and decrease the weight the bottom box carries. </p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#example-2-this-cses-problem","title":"Example 2 (this CSES problem).","text":"<p>Given \\(n\\) people and their programmer skill (\\(skill_1\\)) and artistic skill (\\(skill_2\\)). We need to take exactly \\(a\\) programmers and \\(b\\) artists. Maximise total skill. </p> <p>Step 1. Take all people, at least \\(a\\) programmers and at least \\(b\\) artists. (this eolymp problem)</p> <p>Applying to this problem, the cost (answer) of order \\(AB\\) (take programmer skill of \\(A\\) and artistique skill of \\(B\\)) is \\(skill_1(A) + skill_2(B)\\), and the cost of order \\(BA\\) (take the artistic skill of \\(B\\) and programmer skill of \\(A\\)) is \\(skill_2(A) + skill_1(B)\\). Then \\(cost (AB) &gt; cost (BA)\\) is equivalent to \\(skill_2(A) - skill_1(B) &lt; skill_2(B) - skill_1(A)\\) which we take as our comparator.</p> <p>Step 2. Take exactly \\(a\\) programmers and exactly \\(b\\) artists.</p> <p>Below we describe our implementation of the general strategy.</p> <p>1. (*) Take a person with the best programmer skill (we shall replace bad choices later) and keep a set X containing values of penalty function (\\(skill_2(A) - skill_1(A)\\), as in Step 1) for these choices.</p> <p>2. For other people, declare sets \\(F\\) and \\(S\\) that keep them sorted by the first (second) parameter. These sets will be used to make greedy steps further.</p> <p>3. We take the best \\(b\\) people, replacing previous choices with more optimal ones if needed. Take the object \\(A\\) with the largest artistique skill. And we have two ways further</p> <ul> <li>(Greedy) \\(\\Delta_g\\) = the change of answer if we take \\(A\\) (with the maximal \\(y\\)) and do not change the previous element of the answer.</li> <li>(Replacing) \\(\\Delta_r\\), = the change of answer if we take the maximal \\(x\\) from the other people' and replace the worst (in terms of penalty) choice in (*).</li> </ul> <p>4. Depending on which choice (\"greedy\" or \"replacing) is better we change our sets.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#online-judges","title":"Online Judges","text":"<ol> <li>\u041a\u043e\u0440\u043e\u0431\u043a\u0438 (Boxes) (problem from Example 1, only Russian statement available)</li> <li>Dino and fetters</li> <li>Shoemaker Problem</li> <li>Snow White and n gnomes</li> <li>\u041f\u0440\u0438\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 (Adventure) (only Russian statement available) </li> <li>Inverse Pairs of Binary Strings</li> </ol>"}]}