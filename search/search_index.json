{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>CP-Tricki is a collection of tricks for competitive programming inspired by Tricki.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>To contribute, you can:</p> <ul> <li>Create a pull request from fork (can be fully done via GitHub's web interface)</li> <li>Or, open an issue with proposed changes</li> </ul>"},{"location":"#article-formatting","title":"Article formatting","text":""},{"location":"#article-titles","title":"Article titles","text":"<p>When creating a new Markdown file, specify article title via <pre><code>---\ntitle: Your title\n---\n</code></pre> Another option is to use <code># Your title</code>, but we do not recommend it.</p>"},{"location":"#code","title":"Code","text":"<p>To insert code, use <pre><code>``` c++\n#include &lt;bits/stdc++.h&gt;\n```\n</code></pre> This will render as <pre><code>#include &lt;bits/stdc++.h&gt;\n</code></pre> Specifying programming language after backticks enables code highlighting.</p>"},{"location":"#text-and-subheadings","title":"Text and subheadings","text":"<p>To break text on the page into paragraphs, simply leave a blank line between two bodies of text. To insert subheadings, put <code>## HTML h2 heading</code>, <code>### HTML h3 heading</code>, <code>#### HTML h4 heading</code> etc. on separate line. Using <code># HTML h1 heading</code> is not recommended.</p>"},{"location":"#math","title":"Math","text":"<p>To add math, use <code>\\( n^2 = -1 \\)</code> inline. This will render as \\( n^2 = -1 \\). To put a formula in a separate block, use  <pre><code>blank line\n\\[\n\\int e^x dx = e^x + C\n\\]\nblank line\n</code></pre> This will result in </p> \\[ \\int e^x dx = e^x + C \\] <p>Note: GitHub's preview can display brackets incorrectly.</p>"},{"location":"navigation/","title":"Root navigation","text":"<p>Here is some content which goes above navigation. I can even do things like that:</p> \\[     n^2 \\]"},{"location":"greedy-strategies/","title":"Greedy strategies","text":""},{"location":"greedy-strategies/#some-text","title":"Some text","text":""},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/","title":"How to come up with a comparator?","text":""},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#acknowledgements","title":"Acknowledgements","text":"<p>We start from a simple trick, which was exposed by Sergei Kopeliovich at Winter Programming School in Kharkiv in 2013.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#short-description","title":"Short description","text":"<p>If it seems that a problem can be solved by an algorithm of the form: \"arrange the objects in a suitable way and then work greedily\", there is a general strategy to devise a comparator for this sort.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#prerequisites","title":"Prerequisites","text":"<p>No specific knowledge is required, though familiarity with greedy algorithms would be useful.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#general-description","title":"General description","text":"<p>The auxiliary problem: find an order that optimises a construction (that is the essential part of the considered problem) if it is known that such an order exists.</p> <p>We first consider a simplified problem, when only two objects exist, say \\(A\\) and \\(B\\). Then our comparator should determine which order is better: \\(AB\\)\u00a0or \\(BA\\). To do so, we can normally introduce a penalty\u00a0(or a cost) function \\(f(A,B)\\)\u00a0denoting the amount of penalty\u00a0(or cost) we have if one takes object \\(A\\)\u00a0first and object \\(B\\) second.\u00a0Then our comparator chooses that order in which the penalty is minimal (or cost is maximal). If this comparator (relation) \\(A\\prec B\\) (which is \\(A\\prec B \\iff penalty(A,B)&lt;penalty(B,A)\\) or \\(cost(A,B)&gt;cost(B,A)\\)) is transitive (i.e. if \\(A\\prec B\\) and \\(B\\prec C\\) then \\(A\\prec C\\))\u00a0then after sorting all the objects with respect to it we shall obtain the optimal order.</p> <p>The main problem: find a maximal-size subset that optimises a construction. (The difference from idea 1 is that we are not forced to take all elements.)</p> <p>To do so, we use the comparator from the auxiliary problem, and take objects greedily one by one. At each step, we make a choice:</p> <ol> <li> <p>Put this object into the answer set,</p> </li> <li> <p>Replace an instance in the answer set with this object.</p> </li> </ol> <p>More generally one can write here a knapsack-like dp (if we have a subset we know the order by the auxiliary problem).</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#example-1-a-tower-of-boxes","title":"Example 1 (a tower of boxes)","text":"<p>Given \\(n\\) boxes, each of which has its weight \\(m_i\\) and the weight it can carry on the top \\(a_i\\), determine the size of the largest tower one can build. </p> <p>Step 1. Build a tower of all boxes.  In other words, we need to arrange the boxes in such a way that nothing breaks. Considering two distinct boxes, say \\(i\\) and \\(j\\), we ask: when the order \\((i,j)\\) is better than \\((j,i)\\)? Obviously, that is when the excess of our carrying abilities is greater (that is when the total weight that we can additionally carry is greater). In other words, our cost function looks like this (here box \\(j\\) stands on the top of \\(i\\)): \\(f(i, j) = \\min(\\) total weight that can be still carried by box \\(i\\), total weight that can be still carried by \\(j)\\), i.e. \\(f(i, j) = \\min(a_i - m_j , a_j)\\). Then we will build the tower in descending order of value.</p> <p>Step 2. Build a max-size tower. Sort the boxes in the increasing order with respect to the comparator from Step 1. Take them greedily: if we can put the next box below the already built tower, we do it; otherwise, we ponder whether can we replace some of the boxes in the tower with our current one and decrease the weight the bottom box carries. </p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#example-2-this-cses-problem","title":"Example 2 (this CSES problem).","text":"<p>Given \\(n\\) people and their programmer skill (\\(skill_1\\)) and artistic skill (\\(skill_2\\)). We need to take exactly \\(a\\) programmers and \\(b\\) artists. Maximise total skill. </p> <p>Step 1. Take all people, at least \\(a\\) programmers and at least \\(b\\) artists. (this eolymp problem)</p> <p>Applying to this problem, the cost (answer) of order \\(AB\\) (take programmer skill of \\(A\\) and artistique skill of \\(B\\)) is \\(skill_1(A) + skill_2(B)\\), and the cost of order \\(BA\\) (take the artistic skill of \\(B\\) and programmer skill of \\(A\\)) is \\(skill_2(A) + skill_1(B)\\). Then \\(cost (AB) &gt; cost (BA)\\) is equivalent to \\(skill_2(A) - skill_1(A) &lt; skill_2(B) - skill_1(A)\\) which we take as our comparator.</p> <p>Step 2. Take exactly \\(a\\) programmers and exactly \\(b\\) artists.</p> <p>Below we describe our implementation of the general strategy.</p> <p>1. (*) Take a person with the best programmer skill (we shall replace bad choices later) and keep a set X containing values of penalty function (\\(skill_2(A) - skill_1(A)\\), as in Step 1) for these choices.</p> <p>2. For other people, declare sets \\(F\\) and \\(S\\) that keep them sorted by the first (second) parameter. These sets will be used to make greedy steps further.</p> <p>3. We take the best \\(b\\) people, replacing previous choices with more optimal ones if needed. Take the object \\(A\\) with the largest artistique skill. And we have two ways further</p> <ul> <li>(Greedy) \\(\\Delta_g\\) = the change of answer if we take \\(A\\) (with the maximal \\(y\\)) and do not change the previous element of the answer.</li> <li>(Replacing) \\(\\Delta_r\\), = the change of answer if we take the maximal \\(x\\) from the other people' and replace the worst (in terms of penalty) choice in (*).</li> </ul> <p>4. Depending on which choice (\"greedy\" or \"replacing) is better we change our sets.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#online-judges","title":"Online Judges","text":"<ol> <li>\u041a\u043e\u0440\u043e\u0431\u043a\u0438 (Boxes) (problem from Example 1, only Russian statement available)</li> <li>Dino and fetters</li> <li>Shoemaker Problem</li> <li>Snow White and n gnomes</li> <li>\u041f\u0440\u0438\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 (Adventure) (only Russian statement available) </li> <li>Inverse Pairs of Binary Strings</li> </ol>"},{"location":"greedy-strategies/subgreedy-strategies/title/","title":"Title","text":""},{"location":"greedy-strategies/subgreedy-strategies/title/#title-title","title":"title: Title","text":""}]}