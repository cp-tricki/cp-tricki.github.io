{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>CP-Tricki is a collection of tricks for competitive programming inspired by Tricki.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>To contribute, you can:</p> <ul> <li>Create a pull request from fork (can be fully done via GitHub's web interface)</li> <li>Or, open an issue with proposed changes</li> </ul>"},{"location":"#article-formatting","title":"Article formatting","text":""},{"location":"#article-titles","title":"Article titles","text":"<p>When creating a new Markdown file, specify article title via <pre><code>---\ntitle: Your title\n---\n</code></pre> Another option is to use <code># Your title</code>, but we do not recommend it.</p>"},{"location":"#code","title":"Code","text":"<p>To insert code, use <pre><code>``` c++\n#include &lt;bits/stdc++.h&gt;\n```\n</code></pre> This will render as <pre><code>#include &lt;bits/stdc++.h&gt;\n</code></pre> Specifying programming language after backticks enables code highlighting.</p>"},{"location":"#text-and-subheadings","title":"Text and subheadings","text":"<p>To break text on the page into paragraphs, simply leave a blank line between two bodies of text. To insert subheadings, put <code>## HTML h2 heading</code>, <code>### HTML h3 heading</code>, <code>#### HTML h4 heading</code> etc. on separate line. Using <code># HTML h1 heading</code> is not recommended.</p>"},{"location":"#math","title":"Math","text":"<p>To add math, use <code>\\( n^2 = -1 \\)</code> inline. This will render as \\( n^2 = -1 \\). To put a formula in a separate block, use  <pre><code>blank line\n\\[\n\\int e^x dx = e^x + C\n\\]\nblank line\n</code></pre> This will result in </p> \\[ \\int e^x dx = e^x + C \\] <p>Note: GitHub's preview can display brackets incorrectly.</p>"},{"location":"Miscellaneous/one-can-process-bits-independently-when-relevant/","title":"One can process bits independently when relevant","text":""},{"location":"Miscellaneous/one-can-process-bits-independently-when-relevant/#short-description","title":"Short description","text":"<p>If the problem is related with some bitwise operations (especially xor), try to think and process each bit independently.</p>"},{"location":"Miscellaneous/one-can-process-bits-independently-when-relevant/#prerequisites","title":"Prerequisites","text":"<p>The knowledge of bitmasks (bitwise operations)</p>"},{"location":"Miscellaneous/one-can-process-bits-independently-when-relevant/#general-description","title":"General description","text":"<p>Each integer \\(x\\) can be represented as \\(\\sum\\limits_{k=0}^{M} 2^k \\cdot b_k\\) where \\(b_k\\) is \\(k\\)-th bit in binary representation of the integer and \\(M\\) is \\(\\log_{2}{x}\\).</p> <p>It is often difficult to follow all bits simultaneously, however, we can transform the expression in such way, that bits are calculated independently.</p>"},{"location":"Miscellaneous/one-can-process-bits-independently-when-relevant/#example","title":"Example","text":"<p>The task is to calculate \\(\\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n} (a_l \\oplus \\dots \\oplus a_r)\\)</p> <p>Explanations</p> <p>Let's use the trick so the expression will take form</p> \\[ \\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n} (a_l \\oplus \\dots \\oplus a_r)= \\] \\[ \\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n} (\\sum\\limits_{k=0}^{M} (2^k \\cdot b_{l,k}) \\oplus \\dots \\oplus \\sum\\limits_{k=0}^{M} (2^k \\cdot b_{r,k}))\\overset{*}{=}  \\] \\[ \\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n}\\sum\\limits_{k=0}^{M} 2^k\\cdot (b_{l,k} \\oplus \\dots \\oplus b_{r,k})= \\] \\[ \\sum\\limits_{k=0}^{M}2^k\\cdot \\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n}  (b_{l,k} \\oplus \\dots \\oplus b_{r,k}), \\] <p>where \\(b_{i,k}\\) is the \\(k\\)-th bit of \\(a_i\\) and it is equal to \\(0\\) or \\(1\\).</p> <p>It's correct to do (\\(\\ast\\)) above because multiplying by \\(2^k\\) is equal to shifting \\(k\\) bits right, and \\((a\\ll x)\\oplus (b\\ll x)=(a\\oplus b)\\ll x\\).</p> <p>Actually, the expression \\((b_{l,k} \\oplus \\dots \\oplus b_{r,k})\\) is also equal to \\(0\\) or \\(1\\)(number of ones on the segment is odd). Hence it is much easier to calculate this sum (equivalently the number of segments with odd sum).</p>"},{"location":"Miscellaneous/one-can-process-bits-independently-when-relevant/#online-judge","title":"Online Judge","text":"<ol> <li>Krosh and one more problem with xors</li> <li>Convolution XOR SUM</li> <li>XOR on Segment</li> <li>Present</li> </ol>"},{"location":"dp/translate-dp-to-the-matrix-form/","title":"Translate DP to the matrix form","text":""},{"location":"dp/translate-dp-to-the-matrix-form/#short-description","title":"Short description","text":"<p>Sometimes, we can rewrite our dynamic programming transition formulae using matrices and operations between them (most remarkably multiplication). Then, we can exploit this form in some way.</p>"},{"location":"dp/translate-dp-to-the-matrix-form/#prerequisites","title":"Prerequisites","text":"<p>Basic familiarity with dynamic programming and matrices (linear algebra in general does not required).</p>"},{"location":"dp/translate-dp-to-the-matrix-form/#general-description","title":"General description","text":"<p>We shall not follow the most general setting here, instead focusing on the following DP (linear rerecurrenceelation):</p> \\[     dp_n = a_1 dp_{n-1} + a_2 dp_{n-2} + \\dots + a_k dp_{n-k}. \\] <p>Then, one can notice that the right hand side can be expressed as the dot product</p> \\[     a_1 dp_{n-1} + \\dots + a_k dp_{n-k} =      \\begin{pmatrix}         a_1 &amp; a_2 &amp; \\dots &amp; a_k     \\end{pmatrix}     \\begin{pmatrix}         dp_{n-1} &amp; dp_{n-2} &amp; \\dots &amp; dp_{n-k}     \\end{pmatrix}^T. \\] <p>These vectors on their own are very natural: the first one is our coefficients and the second one keeps our recent values of DP.  The key idea now is to obtain the next vector of recent values, namely \\( \\begin{pmatrix} dp_n &amp; dp_{n-1} &amp; \\dots &amp; dp_{n-k+1} \\end{pmatrix}^T \\).  To do so, we need to apply our previous relation, and then shift all the other values (as well as eliminate \\(dp_{n-k}\\) because we will not need it further). Is it actually easy to shift, so we have the following identity </p> \\[     \\begin{pmatrix}         dp_{n}\\\\         dp_{n-1}\\\\         \\vdots\\\\         dp_{n-k+2}\\\\         dp_{n-k+1}     \\end{pmatrix} =     \\begin{pmatrix}         a_1    &amp; a_2    &amp; \\dots  &amp; a_{k-1} &amp; a_k\\\\         1      &amp; 0      &amp; \\dots  &amp; 0       &amp; 0\\\\         0      &amp; 1      &amp; \\dots  &amp; 0       &amp; 0\\\\         \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots  &amp; \\vdots\\\\         0      &amp; 0      &amp; \\dots  &amp; 1       &amp; 0     \\end{pmatrix}     \\begin{pmatrix}         dp_{n-1} \\\\         dp_{n-2} \\\\         \\vdots\\\\         dp_{n-k+1}\\\\         dp_{n-k}     \\end{pmatrix} \\] <p>Or, in a more compact form (\\(A\\) is the large matrix on the left hand side)</p> \\[     recent_n = A~recent_{n-1}, \\] <p>where \\(recent_n\\) is the vector \\((dp_n, dp_{n-1}, \\dots, dp_{n-k+1}\\) which contains the last \\(k\\) dp values.  We can inductively deduce</p> \\[     recent_n = A recent_{n-1} = A^2 recent_{n-2} = \\dots = A^{n-k+1} recent_{k-1}. \\] <p>Matrix multiplication can be done in \\(O(k^3)\\), and using binary exponentiation we obtain \\(O(k^3 \\log n)\\) algorithm.</p>"},{"location":"dp/translate-dp-to-the-matrix-form/#example-1-constant","title":"Example 1 (+constant)","text":"<p>Given \\(dp_n = A dp_{n-1} + B dp_{n-2} + C\\), find \\(dp_N\\) in \\(O(\\log N)\\) time. </p> <p>We can use the same idea here,</p> \\[     \\begin{pmatrix}dp_n &amp; dp_{n-1} &amp; C\\end{pmatrix} = \\begin{pmatrix}A &amp; B &amp; 1\\end{pmatrix} \\begin{pmatrix} dp_{n-1} &amp; dp_{n-2} &amp; C \\end{pmatrix} \\] <p>only adding a column to our transition matrix and the constant to our \\(recent_n\\) vector.</p>"},{"location":"dp/translate-dp-to-the-matrix-form/#example-2-twisted-dps","title":"Example 2 (twisted DPs)","text":"<p>Sometimes one needs to evaluate several twisted but simple DPs, something like (some random relations just for the sake of illustration):</p> \\[     dp^1_i = f(dp^1_{i-1}, dp^1_{i-2}, dp^2_{i-1}, dp^3_{i-2}), \\] \\[     dp^2_i = g(dp^1_{i-1}, dp^2_{i}, dp^2_{i-1}, dp^2_{i-2}), \\] \\[     dp^3_i = h(dp^2_{i-2}, dp^3_{i-1}). \\] <p>Then one can also use some kind of matrix transformation but with more convoluted \\(recent\\) vectors.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/","title":"How to come up with a comparator?","text":""},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#acknowledgements","title":"Acknowledgements","text":"<p>We start from a simple trick, which was exposed by Sergei Kopeliovich at Winter Programming School in Kharkiv in 2013.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#short-description","title":"Short description","text":"<p>If it seems that a problem can be solved by an algorithm of the form: \"arrange the objects in a suitable way and then work greedily\", there is a general strategy to devise a comparator for this sort.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#prerequisites","title":"Prerequisites","text":"<p>No specific knowledge is required, though familiarity with greedy algorithms would be useful.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#general-description","title":"General description","text":"<p>The auxiliary problem: find an order that optimises a construction (that is the essential part of the considered problem) if it is known that such an order exists.</p> <p>We first consider a simplified problem, when only two objects exist, say \\(A\\) and \\(B\\). Then our comparator should determine which order is better: \\(AB\\)\u00a0or \\(BA\\). To do so, we can normally introduce a penalty\u00a0(or a cost) function \\(f(A,B)\\)\u00a0denoting the amount of penalty\u00a0(or cost) we have if one takes object \\(A\\)\u00a0first and object \\(B\\) second.\u00a0Then our comparator chooses that order in which the penalty is minimal (or cost is maximal). If this comparator (relation) \\(A\\prec B\\) (which is \\(A\\prec B \\iff penalty(A,B)&lt;penalty(B,A)\\) or \\(cost(A,B)&gt;cost(B,A)\\)) is transitive (i.e. if \\(A\\prec B\\) and \\(B\\prec C\\) then \\(A\\prec C\\))\u00a0then after sorting all the objects with respect to it we shall obtain the optimal order.</p> <p>The main problem: find a maximal-size subset that optimises a construction. (The difference from idea 1 is that we are not forced to take all elements.)</p> <p>To do so, we use the comparator from the auxiliary problem, and take objects greedily one by one. At each step, we make a choice:</p> <ol> <li> <p>Put this object into the answer set,</p> </li> <li> <p>Replace an instance in the answer set with this object.</p> </li> </ol> <p>More generally one can write here a knapsack-like dp (if we have a subset we know the order by the auxiliary problem).</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#example-1-a-tower-of-boxes","title":"Example 1 (a tower of boxes)","text":"<p>Given \\(n\\) boxes, each of which has its weight \\(m_i\\) and the weight it can carry on the top \\(a_i\\), determine the size of the largest tower one can build. </p> <p>Step 1. Build a tower of all boxes.  In other words, we need to arrange the boxes in such a way that nothing breaks. Considering two distinct boxes, say \\(i\\) and \\(j\\), we ask: when the order \\((i,j)\\) is better than \\((j,i)\\)? Obviously, that is when the excess of our carrying abilities is greater (that is when the total weight that we can additionally carry is greater). In other words, our cost function looks like this (here box \\(j\\) stands on the top of \\(i\\)): \\(f(i, j) = \\min(\\) total weight that can be still carried by box \\(i\\), total weight that can be still carried by \\(j)\\), i.e. \\(f(i, j) = \\min(a_i - m_j , a_j)\\). Then we will build the tower in descending order of value.</p> <p>Step 2. Build a max-size tower. Sort the boxes in the increasing order with respect to the comparator from Step 1. Take them greedily: if we can put the next box below the already built tower, we do it; otherwise, we ponder whether can we replace some of the boxes in the tower with our current one and decrease the weight the bottom box carries. </p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#example-2-this-cses-problem","title":"Example 2 (this CSES problem).","text":"<p>Given \\(n\\) people and their programmer skill (\\(skill_1\\)) and artistic skill (\\(skill_2\\)). We need to take exactly \\(a\\) programmers and \\(b\\) artists. Maximise total skill. </p> <p>Step 1. Take all people, at least \\(a\\) programmers and at least \\(b\\) artists. (this eolymp problem)</p> <p>Applying to this problem, the cost (answer) of order \\(AB\\) (take programmer skill of \\(A\\) and artistique skill of \\(B\\)) is \\(skill_1(A) + skill_2(B)\\), and the cost of order \\(BA\\) (take the artistic skill of \\(B\\) and programmer skill of \\(A\\)) is \\(skill_2(A) + skill_1(B)\\). Then \\(cost (AB) &gt; cost (BA)\\) is equivalent to \\(skill_2(A) - skill_1(A) &lt; skill_2(B) - skill_1(A)\\) which we take as our comparator.</p> <p>Step 2. Take exactly \\(a\\) programmers and exactly \\(b\\) artists.</p> <p>Below we describe our implementation of the general strategy.</p> <p>1. (*) Take a person with the best programmer skill (we shall replace bad choices later) and keep a set X containing values of penalty function (\\(skill_2(A) - skill_1(A)\\), as in Step 1) for these choices.</p> <p>2. For other people, declare sets \\(F\\) and \\(S\\) that keep them sorted by the first (second) parameter. These sets will be used to make greedy steps further.</p> <p>3. We take the best \\(b\\) people, replacing previous choices with more optimal ones if needed. Take the object \\(A\\) with the largest artistique skill. And we have two ways further</p> <ul> <li>(Greedy) \\(\\Delta_g\\) = the change of answer if we take \\(A\\) (with the maximal \\(y\\)) and do not change the previous element of the answer.</li> <li>(Replacing) \\(\\Delta_r\\), = the change of answer if we take the maximal \\(x\\) from the other people' and replace the worst (in terms of penalty) choice in (*).</li> </ul> <p>4. Depending on which choice (\"greedy\" or \"replacing) is better we change our sets.</p>"},{"location":"greedy-strategies/how-to-come-up-with-a-comparator/#online-judges","title":"Online Judges","text":"<ol> <li>\u041a\u043e\u0440\u043e\u0431\u043a\u0438 (Boxes) (problem from Example 1, only Russian statement available)</li> <li>Dino and fetters</li> <li>Shoemaker Problem</li> <li>Snow White and n gnomes</li> <li>\u041f\u0440\u0438\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 (Adventure) (only Russian statement available) </li> <li>Inverse Pairs of Binary Strings</li> </ol>"}]}